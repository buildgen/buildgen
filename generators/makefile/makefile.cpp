// Copyright 2011 Kevin Cox

/*******************************************************************************
*                                                                              *
*  Permission is hereby granted, free of charge, to any person obtaining a     *
*  copy of this software and associated documentation files (the "Software"),  *
*  to deal in the Software without restriction, including without limitation   *
*  the rights to use, copy, modify, merge, publish, distribute, sublicense,    *
*  and/or sell copies of the Software, and to permit persons to whom the       *
*  Software is furnished to do so, subject to the following conditions:        *
*                                                                              *
*  The above copyright notice and this permission notice shall be included in  *
*  all copies or substantial portions of the Software.                         *
*                                                                              *
*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  *
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    *
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL     *
*  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  *
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING     *
*  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER         *
*  DEALINGS IN THE SOFTWARE.                                                   *
*                                                                              *
*******************************************************************************/

#include "libgen.h"

#include "makefile.hpp"

#include <algorithm>

Makefile::Makefile ( std::set<Target *, Target::comparator> *targets ):
	cwd(getcwd(NULL, 0)),
	cwdlen(strlen(cwd)+1), // The one is to mimic the trailing slash
	targets(targets)
{

}

std::string Makefile::relitiveName(std::string path)
{
	if ( path.find(cwd) != std::string::npos ) // Found it
	{
		std::string s(path.c_str()+cwdlen);

		if ( s[0] == '\0' )
			s = '.';

		std::replace(s.begin(), s.end(), ' ', '?');

		return s;
	}

	std::replace(path.begin(), path.end(), ' ', '?');

	return path;
}

std::string Makefile::generate ( void )
{
	std::string out("# Generated by BuildGen Makefile Generator on ");
	time_t curtime = time(NULL);
	out += ctime(&curtime);
	out += "\n\n.DEFAULT_GOAL := all\n\n";

	for ( std::set<Target *, Target::comparator>::iterator ti = targets->begin();
		  ti != targets->end();
		  ++ti
		)
	{
		out += writeTarget(*ti);
	}

	return out;
}

std::string Makefile::writeTarget(Target *t)
{
	std::string out;

	if ( (t->generator == NULL) && (!t->magic) ) return out; // This is an existing file

	if (t->magic)
	{
		out += ".PHONY: ";
		out += std::string(t->path);
		out += "\n\n";
	}

	out += relitiveName(t->path);
	out += ": ";

	for ( std::set<Target *, Target::comparator>::iterator di = t->depends.begin();
		  di != t->depends.end();
		  ++di
		)
	{
		Target *d = *di;

		out += relitiveName(d->path);
		out += " ";
	}
	if (t->generator) out += relitiveName(t->generator->path);
	out += "\n";
	char *dup = strdup(relitiveName(t->path).c_str());
	std::string dir(dirname(dup));
	free(dup);
	if ( dir != "." )
	{
		out += "	@mkdir -p \'" + dir + "\'\n";
	}
	out += writeGenerator(t->generator);
	out += '\n'; // Skip a line

	return out;
}

std::string Makefile::writeGenerator(Generator *g)
{
	std::string out;

	if (g)
	{
		if ( g->desc != NULL ) out += "	@echo -e '\\e[1m"
		                              +std::string(g->desc)
		                              +"\\e[0m'\n";
		for ( unsigned int i = 0; i < g->cmds.size(); i++ )
		{
			out += '	';
			for ( unsigned int j = 0; j < g->cmds[i].size(); j++ )
			{
				out += '\'';
				out += g->cmds[i][j];
				out += "\' ";
			}
			out += '\n';
		}
	}

	return out;
}
